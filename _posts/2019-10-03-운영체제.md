---
title: "운영체제 정리"
categories: OS
date : 2019-10-03 17:20:00
classes: wide
feature_text: |
  ## 운영체제 정리
tags: OS
---

## 프로세스와 스레드의 차이
### 프로세스
실행 중인 프로그램
메모리에 적재되어 cpu의 할당을 받을 수 있는 것
OS로부터 주소공간, 파일, 메모리 등을 할당받은 것
함수의 매개변수, 임시 자료를 갖는 프로세스 스택, 전역 변수를 수록하는 데이터 섹션 포함

#### 프로세스 제어 블록 (Process Control Block, PCB)
특정 프로세스에 대한 중요한 정보를 저장한 OS의 자료구조
OS는 프로세스 생성과 동시에 고유한 PCB를 생성하여 프로세스를 관리한다.
CPU를 할당받아 작업 처리 중 프로세스 전환이 발생하면 진행하던 작업을 PCB에 저장하고 CPU를 반환한다. 다시 할당받으면 PCB에서 불러와서 이전에 종료되었던 부분부터 다시 수행한다.

PCB에 저장되는 정보
- 프로세스 식별자 PID
- 프로세스 상태 : new, ready, running, waiting, terminated 등
- 프로그램 카운터 : 다음 실행할 명령어 주소
- CPU 레지스터
- CPU 스케쥴링 정보
- 메모리 관리 정보
- 입출력 상태 정보
- 어카운팅 정보

### 스레드
프로세스의 실행 단위
한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.
같은 프로세스 내의 스레드와 같은 운영체제 자원을 공유한다.

#### 멀티 스레드
- 장점
프로세스로 동시에 처리하던 일을 스레드로 구현하면 메모리, 시스템 자원 소모가 줄어든다.
스레드 간 통신에도 전역 변수의 공간이나 동적으로 할당된 heap영역을 이용하여 데이터를 주고 받을 수 있다. 따라서 프로세스 간 통신보다 스레드 간 통신이 훨씬 간단하다.
스레드의 context switch는 캐시 메모리를 비우지 않기에 더 빠르다.

- 문제점
멀티 프로세스 기반은 공유 자원이 없어 동시 접근이 없지만 멀티 스레딩은 아니다.
데이터와 힙 영역을 공유하기 때문에 다른 스레드에서 사용 중인 데이터에 접근하여 엉뚱한 값을 불러오거나 수정할 수 있다.
따라서 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 한다. 하지만 병목현상이 발생할 수 있다.

- 멀티 스레드 vs 멀티 프로세스
멀티 스레드는 빠르지만 오류로 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다.
동기화 문제도 있다.
멀티 프로세스는 하나가 종료되어도 다른 프로세스에 영향이 없지만 많은 메모리 공간과 cpu 시간을 차지한다.

- - - -
## 스케줄러
- job queue : 현재 시스템 내에 있는 모든 프로세스의 집합
- ready queue : 현재 메모리 내에 있으면서 CPU를 잡아 실행되기를 기다리는 프로세스 집합
- device queue : i/o작업 대기하고 있는 프로세스 집합

### 장기 스케줄러 (Long-term scheduler or job scheduler)
메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리에 임시 저장된다. 이 곳에 저장된 프로세스 중 어떤 것을 메모리에 할당하여 ready queue로 보낼지 결정한다.
- 메모리와 디스크 사이의 스케줄링
- 프로세스에 memory를 할당
- 메모리에 몇개의 프로그램이 올라갈지 제어
- 프로세스 상태 : new > ready

### 단기 스케줄러
- CPU와 메모리 사이의 스케줄링
- Ready queue에 존재하는 프로세스 중 어떤 것을 running 시킬지 결정
- 프로세스에 CPU를 할당
- 프로세스 상태 : ready > running > waiting > ready

### 중기 스케줄러
- 여유 공간 마련을 위해 프로세스를 통채로 메모리에서 디스크로 쫓아냄
- 프로세스에게서 메모리를 deallocate
- 메모리에 몇개의 프로그램이 올라갈지 제어
- 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 제어
- 프로세스 상태 : ready > suspended

- - - -
## CPU 스케줄러
### FCFS(First Come First Serve)
- 먼저 온 순서대로 처리
- 비선점형 스케줄링
- 문제점 : 소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮춤

### SJF(Shortest - Job - First)
- 다른 프로세스가 먼저 도착했어도 CPU burst time 이 짧은 프로세스에게 선 할당
- 비선점형
- 문제점 : 사용 시간이 긴 프로세스는 영원히 CPU를 할당받을 수 없다.

### SRT(Shortest Remaining time First)
- 새로운 프로세스가 도착할 때마다 스케줄링
- 선점형 스케줄링
- 문제점 : 새로운 프로세스가 도달할 때마다 스케줄링 하기 때문에 CPU burst time을 측정할 수가 없다.

### Priority Scheduling
- 우선순위가 가장 높은 프로세스에게 CPU할당
- 선점형 방식 : 더 높은 우선순위 프로세스가 도착하면 실행중인 프로세스 멈추고 CPU선점
- 비선점형 방식 : 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 헤더에 넣는다.
- 문제점 : 무기한 봉쇄
- 해결책 : 우선순위가 낮아도 오래기다리면 우선순위를 높여주자

### Round Robin
- 각 프로세스는 동일한 크기의 할당 시간을 갖게된다.
- 할당 시간이 지나면 프로세스는 선점당하고 ready queue의 제일 뒤에 가서 다시 줄을 선다.
- RR은 cpu의 사용시간이 랜덤한 프로세스들이 섞여있을 때 효과적
- 장점
	- response time이 빨라진다.
	- 프로세스가 기다리는 시간이 CPU를 사용할 만큼 증가한다. > 공정한 스케줄링
- 주의점 : 설정한 time quantum이 너무 커지면 FCFS와 같아진다. 너무작아지면 잦은 context switch로 overhead발생

- - - -
## 동기와 비동기의 차이
동기 : 메소드를 실행시킴과 `동시`에 반환 값이 기대되는 경우
동시 > 실행되었을 때 값이 반환되기 전까지는 blocking 되어 있다는 것을 의미
비동기의 경우 blocking되지 않고 이벤트 큐에 넣거나 백그라운드 스레드에게 해당 task를 위임하고 바로 다음 코드를 실행하기 때문에 값이 바로 반환되지 않는다.

- - - -
## 프로세스 동기화
### Critical Section (임계영역)
동일한 자원을 동시에 접근하는 작업을 실행하는 코드

### 문제점
프로세스들이 임계영역을 함께 사용할 수 있는 프로토콜을 설계하는 것
#### 기본 조건
- Mutual Exclusion (상호 배제)
프로세스 P1이 임계구역에서 실행중이라면, 다른 프로세스들은 그들의 임계구역에서 실행될 수 없다.
- Progress(진행)
임계영역에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 진입할 수 있다.
- Bounded waiting
P1이 임계영역에 진입 신청 후 부터 받아들여질 때까지 다른 프로세스들이 임계영역에 진입하는 횟수는 제한이 있어야 한다.

### 해결책
#### Lock
하드웨어 기반 해결책
임계영역에 진입하는 프로세스는 Lock을 획득하고 나올 때 Lock을 방출함으로써 동시에 접근이 되지 않도록 한다.
#### Semaphores (세마포어)
소프트웨어 기반 동기화 도구
- 카운팅 세마포어
가용한 개수를 가진 자원에 대한 접근 제어용, 세마포어는 가용한 자원의 개수로 초기화됨
- 이진 세마포어
MUTEX라고도 불림

단점 : busy waiting , 임계 영역게 진입해야 하는 프로세스는 진입 코드를 계속 반복 실행해야 하며, CPU시간을 낭비하기 됨

DeadLock (교착 상태)
세마포어가 ready queue를 가지고 있고 둘 이상의 프로세스가 임계영역 진입을 무한정 기다리고 있고 임계구역에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되어야 만 빠져나올 수 잇는 상황

- - - -
## 메모리 관리
### Paging
하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법
페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배체됨으로 외부 단편화를 해결할 수 있는 장점이 있다.
단점 : 페이지의 크기가 1024 이고 프로세스가 3172메모리를 요구한다면 3개의 페이지 프레임과 100이 남는다. 총 4개의 페이지 프레임이 필요하기 때문에 4번째 페이지 프레임의 여유공간이 많이 남게되는 내부 단편화 문제가 발생한다.

- - - -
## 가상 메모리
프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법
프로그램이 물리 메모리보다 커도 된다.

### 가상 메모리가 하는 일
실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정의한다.
작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 제공할 수 있다.
#### 가상 주소 공간
- 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간
- 직접적으로 필요하지 않은 메모리 공간은 실제 물리 메모리에 올리지 않아 메모리를 절약할 수 있다.
#### 프로세스간의 페이지 공유
- 시스템 라이브러리가 여러 프로세스들 사이 공유될 수 있도록 한다.
- 프로세스들은 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유됨
- fork()를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게한다.

### Demand Paging
프로그램 실행 시작 시에 프로그램 전체를 물리메모리에 적재하는 대신 필요한 것들만 적재하는 것
한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.

### 페이지 교체
프로세스 동작에 필요한 페이지를 요청하는 것에서 page fault(페이지 부재)가 발생하면 원하는 페이지를 보조저장장치에서 가져온다.
만약 물리 메모리가 모두 사용중이면 페이지 교체가 이뤄져야한다.
1. 디스크에서 필요한 페이지의 위치를 찾는다.
2. 빈 페이지 프레임을 찾는다
	1. 페이지 교체 알고리즘을 통해 희생될 페이지를 고른다.
	2. 희생될 페이지를 디스크에 기록하고 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고 프레임 테이블을 수정한다.	
4. 사용자 프로세스 재시작

#### 페이지 교체 알고리즘
- FIFO (first in first out)
먼저 들어온 페이지 순서대로 페이지 교체 시점에서 먼저 나감
- Optimal Page Replacement 최적 페이지 교체
앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 것
- LRU (Least Recently Used)
가장 오랫동안 사용되지 않은 페이지를 선택하여 교체
- LFU (Least Frequently Used)
참조 횟수가 가장 적은 페이지를 교체
- MFU (Most Frequently Used)

- - - -
## 캐시
### 캐시의 지역성 원리
캐시 메모리는 속도가 빠른 장치와 느린 장치간 속도차에 따른 병목현상을 줄이기 위한 범용 메모리
CPU가 어떤 데이터를 원할 것인지를 예측할 수 있어야 한다.
적중률(Hit rate) 를 극대화 시키기 위해 데이터 지역성의 원리를 사용한다.
지역성은 기억장치 내의 정보를 균일하게 접근하는 것이 아니라 어느 순간에 특정 부분을 집중적으로 참조하는 특성이다.
- 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조됨
- 공간 지역성 : 대부분의 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조됨

- - - -
## CPU 클럭
CPU클럭 속도
클럭 배수 * 시스템 버스 클럭
Hz : 1초에 1번
kHz : 1초에 1000번
MHz : 1초에 1000000번

- - - -
## 패리티 비트
정보 전달 과정에서 오류가 생겼는지를 검사하기 위해 추가된 비트
실제 전송되는 8bit 데이터 끝에 1bit를 더하여 전송하는 방법
짝수 패리티 : (데이터 + 짝수 패리티)의 1의 개수가 짝수가 되도록
홀수 패리티 : (데이터 + 홀수 패리티)의 1의 개수가 홀수가 되도록

데이터 송수신에서 각 비트의 값이 틀어져 0이 1로 아니면 1이 0으로 바뀌었을 때 이를 확인하기 위함
오류 발생 여부를 확인 할 수 있지만 수정은 못한다.
보통 송 수신 거리가 멀 경우 적용되며 짧을 경우에는 Checksum 데이터를 추가하는 기법으로 오류 검출을 한다.

- - - -
## 체크섬 Checksum
중복검사의 한 형태, 송신된 자료의 무결성을 보호하는 방법











