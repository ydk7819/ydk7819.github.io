---
title: "os 요약"
categories: os
classes: wide
date : 2019-10-05 15:20:00
feature_text: |
  ## 운영체제 요약
tags: os
---

## 프로세스 vs 스레드
- 프로세스
	- 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
	- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
	- ![](https://gmlwjd9405.github.io/images/os-process-and-thread/process.png)
- 스레드
	- 프로세스 내에서 실행되는 여러 흐름의 단위
	- 프로세스의 특정한 수행 경로
	- ![](https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png)
- 자바 스레드
	- 일반 스레드와 같다. JVM이 운영체제역할
	- 자바에는 프로세스가 존재하지 않고 스레드만 존재


## 멀티 프로세스 vs 멀티 스레드
- 멀티 프로세스
	- 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리
	- 장점 : 여러 프로세스 중 하나에 문제가 발생하면 그 프로세스만 죽는 것으로 끝남
	- 단점
		- context switching에서 오버헤드
			- 캐쉬 메모리 초기화 등 무거운 작업으로 시간이 소모되는 등 오버헤드 발생
			- 프로세스 각각 독립된 메모리 영역을 할당받았기에 프로세스간 공유메모리가 없어 context switching이 발생하면 캐쉬에 있는 데이터를 리셋해야 함
		- IPC
			- 프로세스 간 통신이 어렵다.
**context switching?**
	- CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정
	- 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태 (context)를 보관하고 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복귀한느 작업

- 멀티 스레드
	- 하나의 으용프로그램을 여러 개의 스레드로 구성하여 각 스레드가 하나의 작업을 처리
	- 장점 
		- 시스템 자원 소모 감소
		- 시스템 처리량 증가
			- 스레드 간 데이터를 주고받는 것이 간단
			- 스레드 사이의 작업량이 작아 문맥교환이 빠르다.
		- 간단한 통신방법으로 인한 프로그램 응답시간 단축
			- 스레드는 프로세스 내의 stack을 제외한 모든 메모리를 공유하기 때문에 통신 부담이 적다.
	- 단점
		- 설계/디버깅 어려움
		- 단일 프로세스 시스템에 효과 미약
		- 다른 프로세스에서 스레드 제어할 수 없다.
		- 멀티 스레드 자원공유문제
		- 하나의 스레드에 문제가 발생하면 전체 프로세스 영향
![](https://gmlwjd9405.github.io/images/os-process-and-thread/multi-thread.png)


## CPU 스케줄링
메모리의 ready 상태의 프로세스 중 하나를 선택해 CPU자원을 할당
**선점과 비선점의 차이**
기존에 CPU를 사용하던 프로세스가 계속 프로세스를 사용할 수 있는데도 불구하고 자원을 빼앗는지 여부

- 비선점
	- 프로세스가 CPU를 할당받으면 완료될 때까지 CPU사용
	- 일괄 처리방식
	- 종류
		- FCFS(First come First Service) : 도착한 순서
		- SJF(Shortest Job First) : 실행시간 순서
		- HRN(Highest Response Ratio) : 우선순위 계산 결과 높은 것 부터 (대기시간+서비스시간/서비스시간)
		- 비선점 우선순위 : 더 높은 우선순위 프로세스가 도착하면 큐의 맨 앞에 넣는다.
- 선점
	- 우선순위가 높은 프로세스가 CPU를 강제로 빼앗아 사용
	- 많은 오버헤드
	- 종류
		- SRT(Shortest Remaining Time) : 현재 실행 중인 프로세스의 남은 시간과 대기 프로세스의 실행시간이 가장 짧은 프로세스에게 CPU할당
		- 선점 우선순위 : 우선순위가 가장 높은 프로세스에게 할당
		- round robin : FCFS를 선점형태로 변환. 할당된 time quantum 동안 CPU를 사용한 뒤에 대기 큐의 가장 뒤로 배치. 할당 시간이 작으면 문맥교환 및 오버헤드 빈번


## 동기 vs 비동기
- 동기 : 메소드를 실행시킴과 동시에 반환 값이 기대되는 경우
- 비동기 : 메소드를 실행시키고 딴 일을 하다가 해당 작업이 완료되면 그에 따른 작업을 처리하는 것


## 페이징 vs 세그먼테이션
- 단편화
	- 프로그램을 할당하고 반납하는 과정을 반복할 때 사용되지 않고 남는 빈 공간
	- 내부 단편화 : 영역이 프로그램보다 커서 남은 공간
	- 외부 단편화 : 영역이 프로그램보다 작아서 할당되지 못해 남아있는 전체 영역
	
- 가상 기억장치
	- 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 것
	- 주기억장치보다 용량이 큰 프로그램을 실행
	- 블록 단위로 나누어 사용하므로 단편화를 해결할 수 있다.

- 페이징
	- 분산 메모리 할당
	- 프레임 : 물리 메모리를 일정된 한 크기로 나눈 블록
	- 페이지 : 가상 메모리를 일정된 한 크기로 나눈 블록
	- 프레임 크기 = 페이지 크기
	- 외부 단편화는 발생하지 않지만 내부 단편화는 발생
	- 페이지 맵 테이블
	- ![](https://t1.daumcdn.net/cfile/tistory/192742394E81D7EC1E)
- 세그멘테이션
	- 가변 크기의 분산 메모리 할당
	- 가변크기의 단위를 세그먼트라 부름
	- 내부 단편화는 발생하지 않지만 외부 단편화는 발생
	- 세그먼트 맵 테이블

- 페이지 : 내부단편화, 동일한 크기로 메모리를 효율적으로 사용
- 세그먼트 : 외부단편화, 공유와 보호의 지원이 편리


## 페이지 크기
- 페이지 크기가 작을 경우
	- 페이지 단편화 감소
	- 국부성에 더 일치할 수 있기 때문에 기억장치 효율이 높아짐
	- 페이지 테이블의 크기가 커져 매핑속도가 느려짐
	- 디스크 접근 횟수가 많아져서 입출력 시간 늘어남
	- 효율적인 워킹 셋
- 페이지 크기가 클 경우
	- 페이지 테이블의 크기가 작아져 매핑속도가 빠름
	- 디스크 접근 횟수가 줄어들어 입출력 효율성 증가
	- 단편화 증가, 한 개의 페이지를 주 기억장치로 이동하는 시간이 늘어남
	- 불필요한 내용도 포함될 수 있음


## 워킹셋 / 페이지 부재
- 워킹셋
	- 프로세스가 일정 시간동안 자주 참조하는 페이지들의 집합
	- 실행중인 프로세스가 주기억장치를 참조할 때는 일부 페이지만 집중적으로 참조하는 성질 (국부성) 이용
	- 자주 참조되는 워킹셋을 주기억장치에 상주시킴으로서 페이지 부재, 교체현상을 줄임\
- 페이지 부재 (page fault)
	- 프로세스 실행 시 참조할 페이지가 주기억장치에 없음
- 스래싱
	- 프로세스의 처리 시간보다 페이지 교체시간이 더 많아짐
	- 자주 페이지 부재가 발생할 때 일어남



